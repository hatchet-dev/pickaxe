import { z } from "zod";
import { pickaxe } from "@/pickaxe-client";

export const time = pickaxe.tool({
  name: "time",
  description: "Get the current time in a given city",
  inputSchema: z.object({
    city: z.string()
  }),
  outputSchema: z.object({
    city: z.string(),
    timezone: z.string(),
    localTime: z.string(),
    utcTime: z.string(),
    summary: z.string()
  }),
  fn: async (input) => {
    try {
      // Use WorldTimeAPI with city/region format (more reliable)
      const cityFormatted = input.city.toLowerCase().replace(/\s+/g, '_');
      
      // Try common timezone patterns for major cities
      const timezoneMappings: Record<string, string> = {
        'new_york': 'America/New_York',
        'los_angeles': 'America/Los_Angeles',
        'chicago': 'America/Chicago',
        'miami': 'America/New_York',
        'denver': 'America/Denver',
        'phoenix': 'America/Phoenix',
        'london': 'Europe/London',
        'paris': 'Europe/Paris',
        'berlin': 'Europe/Berlin',
        'tokyo': 'Asia/Tokyo',
        'sydney': 'Australia/Sydney',
        'toronto': 'America/Toronto',
        'vancouver': 'America/Vancouver'
      };

      let timezone = timezoneMappings[cityFormatted];
      
      if (timezone) {
        // Try the known timezone
        const timeUrl = `https://worldtimeapi.org/api/timezone/${timezone}`;
        const response = await fetch(timeUrl);
        
        if (response.ok) {
          const timeData = await response.json();
          const localTime = new Date(timeData.datetime);
          
          const formattedTime = localTime.toLocaleString('en-US', {
            weekday: 'short',
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            timeZoneName: 'short'
          });
          
          return {
            city: input.city,
            timezone: timezone,
            localTime: formattedTime,
            utcTime: new Date().toISOString(),
            summary: `${formattedTime} in ${input.city}`
          };
        }
      }

      // Fallback: return current UTC time with note
      const utcTime = new Date().toLocaleString('en-US', {
        weekday: 'short',
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        timeZone: 'UTC',
        timeZoneName: 'short'
      });

      return {
        city: input.city,
        timezone: 'UTC',
        localTime: utcTime,
        utcTime: new Date().toISOString(),
        summary: `Current UTC time: ${utcTime} (local time for ${input.city} unavailable)`
      };
      
    } catch (error) {
      // Final fallback
      const utcTime = new Date().toLocaleString('en-US', {
        weekday: 'short',
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        timeZone: 'UTC',
        timeZoneName: 'short'
      });

      return {
        city: input.city,
        timezone: 'UTC',
        localTime: utcTime,
        utcTime: new Date().toISOString(),
        summary: `Current UTC time: ${utcTime} (unable to get time for ${input.city})`
      };
    }
  }
});